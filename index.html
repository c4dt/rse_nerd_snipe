<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nerd Snipe RSECon25</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: #333;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background-color: #f9f9fb;
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        h2 {
            color: #3498db;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 2rem;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .slider-container {
            margin: 2rem auto;
            text-align: center;
        }

        input[type="range"] {
            width: 80%;
            height: 6px;
            border-radius: 3px;
            background: #d1d8e0;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .solution {
            margin-top: 2rem;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .pair {
            display: inline-block;
            margin: 3px 5px;
            padding: 4px 8px;
            background-color: #3498db;
            color: white;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .note {
            font-style: italic;
            color: #7f8c8d;
            margin-top: 1rem;
        }

        .figure {
            text-align: center;
            margin: 1.5rem auto;
            font-size: 0.9em;
            color: #7f8c8d;
        }
    </style>
</head>

<body>

    <h1>Coffee Nerd Snipe @ RSECon25</h1>

    <p><a href="https://rsecon25.society-rse.org/">RSECon25</a> has been a treat — both the organizational tracks and
        the technical tracks were really fun. And as always, the hallway track was even better — even though I really
        have to work on writing down and remembering people's names! Sorry for the folks I didn't recognize from last year :(</p>

    <p>On the last day, Sam Tygier <a href="https://xkcd.com/356/">Nerd Sniped</a> me — well, he was decent enough to
        not do it on a road crossing. But I consider putting me on a mathematical quest on a drinking / board gaming
        evening as
        nerd-sniping.</p>

    <p>The question was this:</p>
    <blockquote>
        <strong>As our group of RSEs grew too large for everybody to know each other organically, I want to organize
            coffee-pairs. Each week I want a list of people and propose them to have a coffee, either IRL or over
            Zoom. The pairs should not repeat.</strong>
    </blockquote>

    <p>An additional question, which I didn't think about yet, is this:</p>
    <blockquote>
        <strong>How to handle absent people and changing group?</strong>
    </blockquote>

    <h2>Some Fundamentals</h2>
    <p>So I got out the paper, pencil, and started to draw some grids and n-grams, and we looked if we can point to an easy
        pattern. Very quickly we realized that it gets complicated, and our first algorithms were NP-something, as we
        needed to try out and search a tree with dead-ends. At one moment we were not sure whether it's possible at all,
        so we counted the possible pairs and the number of pairs necessary:</p>
    <ul>
        <li>Given a team of <code>N</code> RSEs, where <code>N</code> is even</li>
        <li>There are <code>N*(N-1)/2</code> total pairs of RSEs possible</li>
        <li>Looking at RSE #0, they need to have coffee with <code>N-1</code> RSEs, so we can suppose that the coffee
            drinking has to go on for <code>N-1</code> weeks without repetitions</li>
        <li>Dividing the total number of pairs by the number of weeks, we get <code>N/2</code> pairs of coffee per week
            — which is the actual number of pairs, and so there is no contradiction.</li>
    </ul>
    <p>This doesn't prove that it's possible, but at least it doesn't prove it's impossible, so we continued searching.
        By this time we lost Warrick Ball (I'm working on my names but had to ask SaraH, not Sara…) who gave us some
        ideas to help us get along the way.</p>

    <h2>The First Simplification</h2>
    <p>Then we started to fill out the grids of <code>N×N</code> RSEs with <code>A, B, ...</code> for the different
        weeks, and effectively found solutions up to 8 RSEs. Then it got complicated, because there was a lot of
        trial-and-error implied. This is where I left, too, and continued to think about the problem under the pouring
        rain. The beers had their effect and I visualized a tetrahedron where the nodes are RSEs and the edges are
        coffees.</p>

    <div class="figure">
        <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <polygon points="100,20 40,100 160,100" fill="none" stroke="black" />
            <line x1="100" y1="20" x2="100" y2="140" stroke="black" />
            <line x1="40" y1="100" x2="100" y2="140" stroke="black" />
            <line x1="160" y1="100" x2="100" y2="140" stroke="black" />

            <text x="30" y="95" font-size="12">0</text>
            <text x="160" y="95" font-size="12">1</text>
            <text x="95" y="150" font-size="12">2</text>
            <text x="95" y="15" font-size="12">3</text>

            <text x="60" y="130" font-size="12">A0</text>
            <text x="130" y="130" font-size="12">B0</text>
            <text x="80" y="110" font-size="12">C0</text>

            <text x="130" y="60" font-size="12">A1</text>
            <text x="60" y="60" font-size="12">B1</text>
            <text x="100" y="85" font-size="12">C1</text>
        </svg>
    </div>

    <p>So I had a pattern to describe the 3 coffee-weeks (<code>A0/A1</code>, <code>B0/B1</code>, <code>C0/C1</code>) with 4 RSEs. 
        One of the insights was that with <code>N</code>
        RSEs, there are <code>N-1</code> weeks (duh). 
        And if you get an appropriate pattern, like the <code>A0/A1</code>, and rotate it around the
        correct axis, here the vertical one, you can get all pairs for every week.
        I considered an N-dimensional setup of the problem, but quickly
        came back to good old 2D space, as my brain cannot handle more than 4D space. Thinking about the tetrahedron, I
        visualized it from the top (the beer was still strong...), and realized the following:</p>
    <ul>
        <li>There are <code>N-1</code> weeks, so if I use an <code>N-1</code>-gram, and put the <code>Nth</code> node in
            the middle, all I need is a non-repeating pattern connecting the nodes and rotate it <code>N-1</code> times
        </li>
        <li>As there is an odd number of nodes in the <code>N-1</code>-gram, if all the nodes are paired up, there is
            one remaining node</li>
        <li>The <code>Nth</code> node can be put in the middle and be connected to the remaining node</li>
        <li>If the connections between the nodes for week 0 are of distance <code>1, 2, ..., N/2-1</code>, then you can
            rotate this pattern to generate all the <code>N-1</code> weeks, because due to the different distances,
            there will be no repetitions of pairs — and so all possible pairs will be generated (there might have to be
            a proof here, but it sounds intuitive to me)</li>
    </ul>

    <div class="figure" style="display: flex; flex-direction: row; gap: 20px; flex-wrap: wrap; align-items: stretch;">
        <div style="flex: 1 1 400px; min-width: 300px;">
            <canvas id="polygonCanvas" width="400" height="400"></canvas>
        </div>
        <div style="flex: 1 1 200px; min-width: 200px; display: flex; flex-direction: column; gap: 10px;">
            <label for="rseCount"># of RSEs: <span id="rseCountValue"></span></label>
            <input type="range" id="rseCount" min="4" max="10" value="4" step="2">

            <br>
            <label for="weekCount"># of weeks: <span id="weekCountValue"></span></label>
            <input type="range" id="weekCount" min="1" max="3" value="1">
        </div>
    </div>
    </div>

    <p>Now the previous search in a 2D-grid is reduced to a search in a 1D list, where I need to find a pattern to
        construct these connections.</p>

    <h2>Drawing the Pattern</h2>
    <p>After a lot of paper-filling with pen and pencil, and <em>not</em> looking at the internet how to solve this
        problem, I finally <a href="https://www.youtube.com/watch?v=vpPc-eKb67k">saw the light</a>.
        I went through quite some dead-ends and drew the solutions in all kinds of
        ways, before I managed to separate the pairs: Looking at the pairs as <em>even</em> and <em>odd</em> distances
        allows you to always insert one pair in the next higher pair:</p>
    <ul>
        <li><code>A</code> is the pair <code>i, i+1</code> — B is the pair <code>j, j+2</code> — C is the pair
            <code>k, k+3</code> — R is the <em>remaining</em> node which is connected to the node <code>N</code>
        </li>
        <li>The <code>Nth</code> RSE is in the middle of the <code>N-1</code>-gram</li>
        <li>4 RSEs: A A R</li>
        <li>6 RSEs: A A B R B</li>
        <li>8 RSEs: C A A C B R B</li>
        <li>10 RSEs: C A A C D B R B D</li>
    </ul>

    <p>When you draw this in an <code>N-1</code>-gram, you get this very nice drawing:</p>

    <div class="figure" style="display: flex; flex-direction: row; gap: 20px; flex-wrap: wrap; align-items: stretch;">
        <div style="flex: 1 1 400px; min-width: 300px;">
            <canvas id="polygonCanvas2" width="400" height="400"></canvas>
        </div>
        <div style="flex: 1 1 200px; min-width: 200px; display: flex; flex-direction: column; gap: 10px;">
            <label for="rseCount2"># of RSEs: <span id="rseCountValue2"></span></label>
            <input type="range" id="rseCount2" min="4" max="20" value="4" step="2">
            <br>
            <label for="weekCount2"># of weeks: <span id="weekCountValue2"></span></label>
            <input type="range" id="weekCount2" min="1" max="3" value="1">
        </div>
    </div>

    <p>I hope this is a nice enough intuitive description of the problem, as Sam requested :)</p>

    <h2>Putting it All Together</h2>
    <p>To solve the problem of pairing up an even number of <code>N</code> RSEs into <code>N/2</code> pairs for coffee,
        allowing them to go on for <code>N-1</code> weeks without drinking coffee twice with the same person (except if
        they want to, of course), you have to:</p>
    <ol>
        <li>Set up a list of pairs as described above for the <code>N/2</code> groups</li>
        <li>Apply this list to the rotating list <code>[0..N-1]</code> of RSEs</li>
        <li>Send emails</li>
    </ol>

    <div class="slider-container">
        <label for="rses">Number of RSEs: <span id="count">6</span></label>
        <input type="range" id="rses" min="4" max="40" value="16" step="2">
    </div>

    <div id="solution" class="solution"></div>

    <p class="note">If you find an error in this description, please contact
        <a href="mailto:linus.gasser@epfl.ch">Linus Gasser</a>.
    <p class="note">Thanks for Qwen3-30b to create the nice JavaScript-visualizations...</p>

    <!--
    Please judge neither Qwen3-30b too hard for creating sub-par code,
    nor me for accepting code that works at least...
    -->
    <script>
        function drawPolygonWithConnections(canvas, numPoints, connections, rotation = 0) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.8;

            if (rotation === 0) {
                // Draw regular polygon
                ctx.strokeStyle = 'black';
                ctx.beginPath();
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i * Math.PI * 2) / numPoints - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                // Draw middle point
                ctx.beginPath();
                ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw red lines for connections
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            rotation += Math.ceil(numPoints / 4);
            connections.forEach(([a, b]) => {
                let x1, y1, x2, y2;
                if (a === -1) {
                    x1 = centerX;
                    y1 = centerY;
                } else {
                    const angleA = ((a + rotation) * Math.PI * 2) / numPoints - Math.PI / 2;
                    x1 = centerX + radius * Math.cos(angleA);
                    y1 = centerY + radius * Math.sin(angleA);
                }
                if (b === -1) {
                    x2 = centerX;
                    y2 = centerY;
                } else {
                    const angleB = ((b + rotation) * Math.PI * 2) / numPoints - Math.PI / 2;
                    x2 = centerX + radius * Math.cos(angleB);
                    y2 = centerY + radius * Math.sin(angleB);
                }
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });
        }
    </script>

    <script>
        const canvas = document.getElementById('polygonCanvas');
        const ctx = canvas.getContext('2d');
        const connections = [[], [],
        [[0, 1], [2, -1]],
        [[0, 1], [2, 4], [3, -1]],
        [[0, 1], [2, 4], [3, 6], [5, -1]],
        [[0, 1], [2, 5], [3, 7], [4, 6], [8, -1]],
        ];
        function drawSolution(rseCount, weekCount) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let week = 0; week < weekCount; week++) {
                drawPolygonWithConnections(canvas, rseCount - 1, connections[rseCount / 2], week);
            }
        }

        // Update week selector based on RSE count
        document.getElementById('rseCount').addEventListener('input', function () {
            const rseCount = parseInt(this.value);
            const rseCountValue = document.getElementById('rseCountValue');
            rseCountValue.innerHTML = rseCount;
            const weekSelect = document.getElementById('weekCount');
            weekSelect.max = rseCount - 1;
            weekSelect.value = 1;
            drawSolution(rseCount, parseInt(weekSelect.value));
        });

        // Handle week change
        document.getElementById('weekCount').addEventListener('input', function () {
            const rseCount = parseInt(document.getElementById('rseCount').value);
            const weekCount = parseInt(this.value);
            const weekCountValue = document.getElementById('weekCountValue');
            weekCountValue.innerHTML = weekCount;
            drawSolution(rseCount, weekCount);
        });

        // Initialize week selector on load
        document.getElementById('rseCount').dispatchEvent(new Event('input'));
        document.getElementById('weekCount').dispatchEvent(new Event('input'));
    </script>

    <script>
        function calcConnections(totalPairs) {
            // console.log(`totalPairs: ${totalPairs}`);
            let connections = [];
            let oddEnd = Math.floor(totalPairs / 2) * 2 - 1;
            let evenStart = oddEnd + 1;
            let evenEnd = totalPairs * 2 - 2;
            for (let oddStart = 0; oddStart < oddEnd; oddStart++, oddEnd--) {
                // console.log(`odd: ${oddStart}..${oddEnd}`);
                connections.push([oddStart, oddEnd]);
            }
            for (; evenStart < evenEnd; evenStart++, evenEnd--) {
                // console.log(`even: ${evenStart}..${evenEnd}`);
                connections.push([evenStart, evenEnd]);
            }
            // console.log(`middle: ${evenStart}..-1`);
            connections.push([evenStart, -1]);
            return connections;
        }

        const canvas2 = document.getElementById('polygonCanvas2');
        const ctx2 = canvas2.getContext('2d');
        const connections2 = [[], []];
        for (let i = 2; i <= 10; i++) {
            connections2.push(calcConnections(i));
        }
        console.log(JSON.stringify(connections2));

        function drawSolution2(rseCount, weekCount) {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            for (let week = 0; week < weekCount; week++) {
                drawPolygonWithConnections(canvas2, rseCount - 1, connections2[rseCount / 2], week);
            }
        }

        // Update week selector based on RSE count
        document.getElementById('rseCount2').addEventListener('input', function () {
            const rseCount = parseInt(this.value);
            const rseCountValue = document.getElementById('rseCountValue2');
            rseCountValue.innerHTML = rseCount;
            const weekSelect = document.getElementById('weekCount2');
            weekSelect.max = rseCount - 1;
            weekSelect.value = 1;
            document.getElementById('weekCount2').dispatchEvent(new Event('input'));
            drawSolution2(rseCount, parseInt(weekSelect.value));
        });

        // Handle week change
        document.getElementById('weekCount2').addEventListener('input', function () {
            const rseCount = parseInt(document.getElementById('rseCount2').value);
            const weekCount = parseInt(this.value);
            const weekCountValue = document.getElementById('weekCountValue2');
            weekCountValue.innerHTML = weekCount;
            drawSolution2(rseCount, weekCount);
        });

        // Initialize week selector on load
        document.getElementById('rseCount2').dispatchEvent(new Event('input'));
        document.getElementById('weekCount2').dispatchEvent(new Event('input'));
    </script>

    <script>
        const slider = document.getElementById('rses');
        const countDisplay = document.getElementById('count');
        const solutionDiv = document.getElementById('solution');

        function renderSolution(n) {
            const connections = calcConnections(n / 2);
            const range = Array.from({ length: n }, (_, i) => i);
            let result = '';
            for (let week = 0; week < n - 1; week++) {
                const rotated = [...range.slice(week), ...range.slice(0, week)];
                result += `<p><strong>Week ${week + 1}:</strong> `;
                let pairs = [];
                for (let conn of connections) {
                    const a = rotated[conn[0]];
                    const b = rotated[conn[1] >= 0 ? conn[1] : n - 1];
                    pairs.push(`<span class="pair">${a}-${b}</span>`);
                }
                result += pairs.join(' ');
                result += '</p>';
            }
            return result;
        }

        slider.addEventListener('input', function () {
            const n = parseInt(this.value);
            countDisplay.textContent = n;
            solutionDiv.innerHTML = renderSolution(n);
        });

        // Initial render
        slider.dispatchEvent(new Event('input'));
    </script>

</body>

</html>